import sys
from pathlib import Path

# Add utils to path
sys.path.append(str(Path(__file__).parent.parent))

from utils.solution_template import Solution

class Day11(Solution):
    def __init__(self):
        super().__init__(day=11)
        
    def load_data(self):
        # Override to handle test cases differently
        self.test_inputs = self.read_test_inputs()
        self.real_data = self.read_input(test=False)
        return self
    
    def read_test_inputs(self):
        # Read test inputs from file with comments
        filepath = Path(__file__).parent / "test.txt"
        test_inputs = []
        
        with open(filepath, 'r') as f:
            for line in f:
                clean_line = line.strip()
                if clean_line and not clean_line.startswith('#'):
                    test_inputs.append(clean_line)
        return test_inputs
    
    def read_input(self, test=False):
        # Read input file
        filename = "test.txt" if test else "input.txt"
        filepath = Path(__file__).parent / filename
        
        with open(filepath, 'r') as f:
            return f.read().strip() # Use for char by char reading inside part1/2
    
    def part1(self, data):
        curr = data
        
        def increment(pw):
            # Handles the 'increment each letter starting from rightmost and moving backwards'
            pw_list = list(pw)
            i = len(pw_list) - 1
            while i >= 0:
                if pw_list[i] != 'z':
                    pw_list[i] = chr(ord(pw_list[i]) + 1)
                    break
                else:
                    pw_list[i] = 'a'
                i -= 1
            return ''.join(pw_list)
        
        def is_valid(pw):
            # Looks for three consecutive letters
            has_straight = False
            for i in range(len(pw) - 2):
                if ord(pw[i+2]) - ord(pw[i+1]) == 1 and ord(pw[i+1]) - ord(pw[i]) == 1:
                    has_straight = True
                    break
            
            # Checks for forbidden letters
            no_forbidden = not any(c in pw for c in 'ilo')
            
            # Looks for at least two different pairs
            pairs = set()
            j = 0
            while j < len(pw) - 1:
                if pw[j] == pw[j+1]:
                    pairs.add(pw[j])
                    j += 2
                else:
                    j += 1
            has_two_pairs = len(pairs) >= 2
            
            return has_straight and no_forbidden and has_two_pairs
        
        while True:
            curr = increment(curr)
            if is_valid(curr):
                return curr
    
    def part2(self, data):
        # Same as part1, but using the password generated by part1
        curr = self.part1(data)
        
        def increment(pw):
            # Handles the 'increment each letter starting from rightmost and moving backwards'
            pw_list = list(pw)
            i = len(pw_list) - 1
            while i >= 0:
                if pw_list[i] != 'z':
                    pw_list[i] = chr(ord(pw_list[i]) + 1)
                    break
                else:
                    pw_list[i] = 'a'
                i -= 1
            return ''.join(pw_list)
        
        def is_valid(pw):
            # Looks for three consecutive letters
            has_straight = False
            for i in range(len(pw) - 2):
                if ord(pw[i+2]) - ord(pw[i+1]) == 1 and ord(pw[i+1]) - ord(pw[i]) == 1:
                    has_straight = True
                    break
            
            # Checks for forbidden letters
            no_forbidden = not any(c in pw for c in 'ilo')
            
            # Looks for at least two different pairs
            pairs = set()
            j = 0
            while j < len(pw) - 1:
                if pw[j] == pw[j+1]:
                    pairs.add(pw[j])
                    j += 2
                else:
                    j += 1
            has_two_pairs = len(pairs) >= 2
            
            return has_straight and no_forbidden and has_two_pairs
        
        while True:
            curr = increment(curr)
            if is_valid(curr):
                return curr
        
    def run_tests(self):
        # Run all test cases with expected results
        print(f"--- Day {self.day:02d} Test Cases ---")
        for i, test_input in enumerate(self.test_inputs, 1):
            result = self.part1(test_input)
            print(f"Test {i}: '{test_input}' -> {result}")
    
    def run(self):
        # Run both parts with test and real data
        if not hasattr(self, 'test_inputs'):
            self.load_data()
        
        # Run individual test cases
        self.run_tests()
        print()
        
        # Run on real data
        print("--- Real Data ---")
        real_result1 = self.part1(self.real_data)
        print(f"Part 1: {real_result1}")
        
        try:
            real_result2 = self.part2(self.real_data)
            print(f"Part 2: {real_result2}")
        except Exception as e:
            print(f"Part 2 not implemented: {e}")

if __name__ == "__main__":
    solution = Day11()
    solution.run()
